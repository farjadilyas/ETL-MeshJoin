/*
  Muhammad Farjad Ilyas - 18I-0436 - Data Warehousing Section A

  NOTE:
  1. I used MySQL, which doesn't support several useful clauses & functions for OLAP queries, such as ROLLUP(), GROUPING(), GROUPING SETS()
  2. Most importantly, MySQL lacks the support for rolling up a subset of the dimensions listed with the GROUP BY clause
  3. Hence I used two approaches to make up for that:
    a. Use WITH ROLLUP clause which rolls up all dimensions listed in front of the GROUP BY clause, and use NULL checks
         in the HAVING clause to remove roll ups which aren't required
    b. Use UNION ALL to join queries, each one of which simulates a single clause which would normally be fed to the
         GROUPING SETS() function. This achieves our goal of only rollup up a subset of the columns listed with the
         GROUP BY clause
*/


USE dwh_project;

-- ========================================================
-- QUERY 1
-- ========================================================

-- V1: Using ROLLUP with NULL checks

SELECT SP.SUPPLIER_NAME, T.QTR_NUM AS QUARTER, IFNULL(T.MONTH_NUM, 'ALL MONTHS') AS MONTH_NUM, SUM(SLS.TOTAL_SALE) AS TOTAL_SALE
FROM SALES SLS
         INNER JOIN SUPPLIERS SP ON SLS.SUPPLIER_ID = SP.SUPPLIER_ID
         INNER JOIN TIME_DIM T ON SLS.TIME_ID = T.TIME_ID
GROUP BY SP.SUPPLIER_ID, T.QTR_NUM, T.MONTH_NUM WITH ROLLUP
HAVING SP.SUPPLIER_NAME IS NOT NULL AND T.QTR_NUM IS NOT NULL;

-- V2: USING UNION ALL
SELECT R.SUPPLIER_NAME, R.QTR_NUM AS QUARTER, R.MONTH_NUM, R.TOTAL_SALE FROM (
                  SELECT SP.SUPPLIER_NAME, T.QTR_NUM, T.MONTH_NUM, SUM(SLS.TOTAL_SALE) AS TOTAL_SALE
                  FROM SALES SLS
                           INNER JOIN SUPPLIERS SP ON SLS.SUPPLIER_ID = SP.SUPPLIER_ID
                           INNER JOIN TIME_DIM T ON SLS.TIME_ID = T.TIME_ID
                  GROUP BY SP.SUPPLIER_ID, T.QTR_NUM, T.MONTH_NUM
                  UNION ALL
                  SELECT SP.SUPPLIER_NAME, T.QTR_NUM, 'ALL MONTHS' AS MONTH_NUM, SUM(SLS.TOTAL_SALE) AS TOTAL_SALE
                  FROM SALES SLS
                           INNER JOIN SUPPLIERS SP ON SLS.SUPPLIER_ID = SP.SUPPLIER_ID
                           INNER JOIN TIME_DIM T ON SLS.TIME_ID = T.TIME_ID
                  GROUP BY SP.SUPPLIER_ID, T.QTR_NUM
              ) AS R
ORDER BY R.SUPPLIER_NAME, R.QTR_NUM, R.MONTH_NUM;

-- ========================================================
-- QUERY 2
-- ========================================================
SELECT ST.STORE_ID, ST.STORE_NAME, IFNULL(P.PRODUCT_ID, 'ALL PRODUCTS') AS PRODUCT_ID, CASE WHEN P.PRODUCT_ID IS NULL THEN 'ALL PRODUCTS' ELSE P.PRODUCT_NAME END AS PRODUCT_NAME, SUM(SLS.TOTAL_SALE) AS TOTAL_SALE
FROM SALES SLS
         INNER JOIN STORES ST ON SLS.STORE_ID  = ST.STORE_ID
         INNER JOIN PRODUCTS P ON SLS.PRODUCT_ID = P.PRODUCT_ID
GROUP BY ST.STORE_ID, P.PRODUCT_ID WITH ROLLUP
HAVING ST.STORE_ID IS NOT NULL;

-- ========================================================
-- QUERY 3
-- ========================================================
SELECT P.PRODUCT_ID, P.PRODUCT_NAME, SUM(SLS.QUANTITY) NUM_ITEMS_SOLD
FROM SALES SLS
         INNER JOIN TIME_DIM T ON SLS.TIME_ID = T.TIME_ID
         INNER JOIN PRODUCTS P ON SLS.PRODUCT_ID = P.PRODUCT_ID
WHERE T.DAY_OF_WEEK IN ('SATURDAY', 'SUNDAY')
GROUP BY P.PRODUCT_ID
ORDER BY SUM(SLS.QUANTITY) DESC
LIMIT 5;

-- ========================================================
-- QUERY 4
-- ========================================================

-- Using CASE and SUM: This is effectively same as creating a pivot table that is not dynamic.
-- However, a quarter can be one of 4 possibilities, so a static pivot table is appropriate
SELECT
    P.PRODUCT_ID, P.PRODUCT_NAME,
    SUM(CASE WHEN T.QTR_NUM = 1 THEN SLS.TOTAL_SALE ELSE 0 END) AS QTR1_SALES,
    SUM(CASE WHEN T.QTR_NUM = 2 THEN SLS.TOTAL_SALE ELSE 0 END) AS QTR2_SALES,
    SUM(CASE WHEN T.QTR_NUM = 3 THEN SLS.TOTAL_SALE ELSE 0 END) AS QTR3_SALES,
    SUM(CASE WHEN T.QTR_NUM = 4 THEN SLS.TOTAL_SALE ELSE 0 END) AS QTR4_SALES
FROM SALES SLS
         INNER JOIN TIME_DIM T ON SLS.TIME_ID = T.TIME_ID
         INNER JOIN PRODUCTS P ON SLS.PRODUCT_ID = P.PRODUCT_ID
WHERE T.YEAR_NUM = 2016
GROUP BY P.PRODUCT_ID;


-- ========================================================
-- QUERY 5
-- ========================================================

-- V1: USING WITH ROLLUP
SELECT P.PRODUCT_ID, P.PRODUCT_NAME, T.YEAR_NUM,
       CASE WHEN T.QTR_NUM IN (1, 2) THEN 'First' ELSE 'Second' END AS YEAR_HALF,
       SUM(SLS.TOTAL_SALE) AS YEARLY_SALE
FROM SALES SLS
         INNER JOIN TIME_DIM T ON SLS.TIME_ID = T.TIME_ID
         INNER JOIN PRODUCTS P ON SLS.PRODUCT_ID = P.PRODUCT_ID
WHERE T.YEAR_NUM = 2016
GROUP BY P.PRODUCT_ID, CASE WHEN T.QTR_NUM IN (1, 2) THEN 'First' ELSE 'Second' END WITH ROLLUP
HAVING P.PRODUCT_ID IS NOT NULL;

-- V2: USING UNION ALL
SELECT * FROM (
                  SELECT P.PRODUCT_ID, P.PRODUCT_NAME, T.YEAR_NUM,
                         CASE WHEN T.QTR_NUM IN (1, 2) THEN 'First' ELSE 'Second' END AS YEAR_HALF,
                         SUM(SLS.TOTAL_SALE) AS YEARLY_SALE
                  FROM SALES SLS
                           INNER JOIN TIME_DIM T ON SLS.TIME_ID = T.TIME_ID
                           INNER JOIN PRODUCTS P ON SLS.PRODUCT_ID = P.PRODUCT_ID
                  WHERE T.YEAR_NUM = 2016
                  GROUP BY P.PRODUCT_ID, CASE WHEN T.QTR_NUM IN (1, 2) THEN 'First' ELSE 'Second' END
                  UNION ALL
                  SELECT P.PRODUCT_ID, P.PRODUCT_NAME, T.YEAR_NUM,
                         'BOTH' AS YEAR_HALF,
                         SUM(SLS.TOTAL_SALE) AS YEARLY_SALE
                  FROM SALES SLS
                           INNER JOIN TIME_DIM T ON SLS.TIME_ID = T.TIME_ID
                           INNER JOIN PRODUCTS P ON SLS.PRODUCT_ID = P.PRODUCT_ID
                  WHERE T.YEAR_NUM = 2016
                  GROUP BY P.PRODUCT_ID
                  ) AS R
ORDER BY R.PRODUCT_ID, R.YEAR_NUM, R.YEAR_HALF;
;


-- ========================================================
-- QUERY 6: Find anomaly
-- ========================================================

-- Two product ids have the same product name. Given just this information, they should map to a single product id
SELECT COUNT(DISTINCT(PRODUCT_ID)) FROM MASTERDATA; -- gives 100
SELECT COUNT(DISTINCT(PRODUCT_NAME)) FROM MASTERDATA; -- gives 99

-- The following query find any products with the same name but different ids
-- The result shows that 'Tomatoes' is a duplicate entry, assigned two different product ids

-- NOTE: The same result can be obtained by querying the MASTERDATA table instead, using the same query otherwise
SELECT P.PRODUCT_ID, P.PRODUCT_NAME
FROM PRODUCTS P,
     (SELECT PRODUCT_NAME, COUNT(*)
      FROM PRODUCTS
      GROUP BY PRODUCT_NAME
      HAVING COUNT(*) > 1) AS R
WHERE P.PRODUCT_NAME = R.PRODUCT_NAME;



-- ========================================================
-- QUERY 7: Create materialized view using a true table, and insert, update & delete triggers
-- ========================================================
DROP TABLE IF EXISTS STOREANALYSIS_MV;

CREATE TABLE STOREANALYSIS_MV AS
SELECT ST.STORE_ID, P.PRODUCT_ID, SUM(SLS.TOTAL_SALE) AS TOTAL_SALES_PER_STORE_PRODUCT, SUM(SLS.QUANTITY) AS QUANTITY_PER_STORE_PRODUCT
FROM SALES SLS
         INNER JOIN PRODUCTS P ON SLS.PRODUCT_ID = P.PRODUCT_ID
         INNER JOIN STORES ST ON SLS.STORE_ID = ST.STORE_ID
GROUP BY ST.STORE_NAME, P.PRODUCT_NAME
ORDER BY ST.STORE_NAME, P.PRODUCT_NAME;

SELECT * FROM STOREANALYSIS_MV;


-- INSERT TRIGGER
DROP TRIGGER IF EXISTS STOREANALYSIS_INS_TRG;
CREATE TRIGGER STOREANALYSIS_INS_TRG
    AFTER INSERT ON SALES
    FOR EACH ROW
BEGIN
    DECLARE SALE_AGG DECIMAL(7, 2)
	DECLARE QUANTITY_AGG DECIMAL(3, 0)
    DECLARE NEED_UPDATE NUMERIC(1)

    SET NEED_UPDATE := 0
    SELECT 1, TOTAL_SALES_PER_STORE_PRODUCT, QUANTITY_PER_STORE_PRODUCT INTO NEED_UPDATE, SALE_AGG, QUANTITY_AGG
    FROM STOREANALYSIS_MV
    WHERE STORE_ID = NEW.STORE_ID AND PRODUCT_ID = NEW.PRODUCT_ID

    IF NEED_UPDATE = 0 THEN
        INSERT INTO STOREANALYSIS_MV VALUES(NEW.STORE_ID, NEW.PRODUCT_ID, NEW.TOTAL_SALE, NEW.QUANTITY)
    ELSE
    SALE_AGG := SALE_AGG + NEW.TOTAL_SALE
    QUANTITY_AGG := QUANTITY_AGG + NEW.QUANTITY

    UPDATE STOREANALYSIS_MV
    SET TOTAL_SALES_PER_STORE_PRODUCT = SALE_AGG,
        QUANTITY_PER_STORE_PRODUCT = QUANTITY_AGG
    WHERE STORE_ID = NEW.STORE_ID AND PRODUCT_ID = NEW.PRODUCT_ID
END IF
END
/
DELIMITER ;


-- UPDATE TRIGGER
DROP TRIGGER IF EXISTS STOREANALYSIS_UPT_TRG;
CREATE TRIGGER STOREANALYSIS_UPT_TRG
    AFTER UPDATE ON SALES
    FOR EACH ROW
BEGIN
    DECLARE SALE_AGG DECIMAL(7, 2)
	DECLARE QUANTITY_AGG DECIMAL(3, 0)
    DECLARE NEED_UPDATE NUMERIC(1)

    SET NEED_UPDATE := 0
    SELECT 1, TOTAL_SALES_PER_STORE_PRODUCT, QUANTITY_PER_STORE_PRODUCT INTO NEED_UPDATE, SALE_AGG, QUANTITY_AGG
    FROM STOREANALYSIS_MV
    WHERE STORE_ID = NEW.STORE_ID AND PRODUCT_ID = NEW.PRODUCT_ID

    IF NEED_UPDATE = 0 THEN
        INSERT INTO STOREANALYSIS_MV VALUES(NEW.STORE_ID, NEW.PRODUCT_ID, NEW.TOTAL_SALE, NEW.QUANTITY)
    ELSE
        SALE_AGG := SALE_AGG - OLD.TOTAL_SALE + NEW.TOTAL_SALE
        QUANTITY_AGG := QUANTITY_AGG - OLD.QUANTITY + NEW.QUANTITY

        UPDATE STOREANALYSIS_MV
        SET TOTAL_SALES_PER_STORE_PRODUCT = SALE_AGG,
            QUANTITY_PER_STORE_PRODUCT = QUANTITY_AGG
        WHERE STORE_ID = NEW.STORE_ID AND PRODUCT_ID = NEW.PRODUCT_ID
    END IF
END
/
DELIMITER ;

-- DELETE TRIGGER
DROP TRIGGER IF EXISTS STOREANALYSIS_DLT_TRG;
CREATE TRIGGER STOREANALYSIS_DLT_TRG
    AFTER DELETE ON SALES
    FOR EACH ROW
BEGIN
    DECLARE SALE_AGG DECIMAL(7, 2)
	DECLARE QUANTITY_AGG DECIMAL(3, 0)

    SELECT TOTAL_SALES_PER_STORE_PRODUCT, QUANTITY_PER_STORE_PRODUCT INTO SALE_AGG, QUANTITY_AGG
    FROM STOREANALYSIS_MV
    WHERE STORE_ID = NEW.STORE_ID AND PRODUCT_ID = NEW.PRODUCT_ID

    SALE_AGG := SALE_AGG - OLD.TOTAL_SALE
    QUANTITY_AGG := QUANTITY_AGG - OLD.QUANTITY

    UPDATE STOREANALYSIS_MV
    SET TOTAL_SALES_PER_STORE_PRODUCT = SALE_AGG,
        QUANTITY_PER_STORE_PRODUCT = QUANTITY_AGG
    WHERE STORE_ID = NEW.STORE_ID AND PRODUCT_ID = NEW.PRODUCT_ID
END
/
DELIMITER ;

-- TESTING INSERT , UPDATE, AND DELETE TRIGGERS
INSERT INTO SALES VALUES(10001, 'P-1001', 'C-20', 'S-6', '2016-08-22', 'SP-2', 1, 10);

UPDATE SALES
SET TOTAL_SALE = 20
WHERE TRANSACTION_ID = 10001;

DELETE FROM SALES WHERE TRANSACTION_ID = 10001;


-- This query will give a total sales of 893.47 after insert
-- 903.47 after update
-- 883.47 after deletion, showing that all three triggers work
SELECT ST.STORE_ID, P.PRODUCT_ID, SUM(SLS.TOTAL_SALE) AS TOTAL_SALES_PER_STORE_PRODUCT, SUM(SLS.QUANTITY) AS QUANTITY_PER_STORE_PRODUCT
FROM SALES SLS
         INNER JOIN PRODUCTS P ON SLS.PRODUCT_ID = P.PRODUCT_ID
         INNER JOIN STORES ST ON SLS.STORE_ID = ST.STORE_ID
WHERE P.PRODUCT_ID = 'P-1001' AND ST.STORE_ID = 'S-6'
GROUP BY ST.STORE_NAME, P.PRODUCT_NAME
ORDER BY ST.STORE_NAME, P.PRODUCT_NAME;